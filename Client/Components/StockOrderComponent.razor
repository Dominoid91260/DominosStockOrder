@using DominosStockOrder.Client.Services
@using DominosStockOrder.Shared.ViewModels
@inject FoodTheoService FoodTheo

<button class="btn btn-warning w-100 mb-3" @onclick="@CalculateFinalOrderForAllItems">Calculate Final Order</button>

<div class="accordion" id="orderItems">
    <StockOrderSection UniqueId="suggested" Title="Suggested Products" Items="@_suggestedItems" />
    <StockOrderSection UniqueId="manual" Title="Manual Count Products" Items="@_manualItems" />
</div>

@code {
    [Parameter]
    public StockOrderRequestVM Order { get; set; }

    private IEnumerable<StockOrderRequestItemVM> _suggestedItems;
    private IEnumerable<StockOrderRequestItemVM> _manualItems;

    protected override void OnParametersSet()
    {
        var grouped = Order.Items.GroupBy(i => i.DatabaseInfo.ManualCount);
        var selected = grouped.Select(g => new
        {
            IsManualCount = g.Key,
            Items = g.AsEnumerable()
        });

        _suggestedItems = selected.Where(x => !x.IsManualCount).SelectMany(x => x.Items).ToList();
        _manualItems = selected.Where(x => x.IsManualCount).SelectMany(x => x.Items).ToList();
    }

    private void CalculateFinalOrderForAllItems()
    {
        foreach (var item in Order.Items)
        {
            CalculateFinalOrderForItem(item);
        }

        StateHasChanged();
    }

    private void CalculateFinalOrderForItem(StockOrderRequestItemVM item)
    {
        Console.WriteLine($"CalculateFinalOrder {item?.Description} | {item?.DatabaseInfo?.Multiplier}");
        if (item.DatabaseInfo is null || item.DatabaseInfo.ManualCount || !FoodTheo.Workings.TryGetValue(item.PulseCode, out var working))
            return;

        const int originIdeal = 0;
        const int inTransit = 0;

        var currentStock = working.WeeklyFoodTheo.DefaultIfEmpty(0).Average();
        var soldLastWeekTotal = item.RollingAverage * item.DatabaseInfo.Multiplier + originIdeal;
        var totalInStoreInTransit = currentStock + inTransit;
        var totalNeeded = totalInStoreInTransit - soldLastWeekTotal;
        var unitsRequired = totalNeeded / item.DatabaseInfo.PackSize; // `unitsRequired` is negative since its the difference between what we have and what we sold

        var sign = MathF.Sign(unitsRequired);

        Console.WriteLine(item.Description);
        Console.WriteLine($"\tSold Last Week: {item.RollingAverage}");
        Console.WriteLine($"\tToday Opening: {currentStock}");
        Console.WriteLine($"\tSold Last Week Total: {soldLastWeekTotal}");
        Console.WriteLine($"\tTotal In Store/Transit: {totalInStoreInTransit}");
        Console.WriteLine($"\tTotal Stock Needed: {totalNeeded}");
        Console.WriteLine($"\tUnits Required: {unitsRequired}");
        Console.WriteLine($"\tPack Size: {item.DatabaseInfo.PackSize}");
        Console.WriteLine($"\tMultiplier: {item.DatabaseInfo.Multiplier}");

        // If unitsRequired is positive it means we dont need anything as we have more in store than what we used.
        if (sign >= 0)
        {
            item.FinalOrder = 0;
        }
        else
        {
            item.FinalOrder = (int)Math.Abs(Math.Round(unitsRequired));
        }

        Console.WriteLine($"\tFinal order: {item.FinalOrder}\n");
    }
}